microx = "microx_version = ""2.5"" // updated for grey hack v0.7.3574 Nightly Alpha\n\ngetParam = function(paramType)\n	rnp=0\n	for param in params\n		if rnp then return param\n		if param == (paramType) then rnp=1\n	end for\n	return false\nend function\n\nloadLibrary = function(libFileName, search)\n	paths=[""""]\n	if search then paths = [current_path, ""/lib"", ""/bin"", ""/usr/bin""]\n	for p in paths\n		lib = include_lib(p + ""/"" + libFileName)\n		if lib then return lib\n	end for\n	error(""Could not find requested library: "" + libFileName)\n	return false\nend function\n\nloadMetaXPloit = function()\n	return loadLibrary(""metaxploit.so"", true)\nend function\n\nisAParam = function(paramType)\n	for param in params\n		if param.lower == paramType.lower then return true\n	end for\n	return false\nend function\n\nerror = function(str)\n	print(""<color=#FF2222><b>  ERROR: </b></color>"" + str)\nend function\n\ninfo = function(str)\n	if isAParam(""-v"") then print(""<I>  Info: "" + str + ""</I>"")\nend function\n\ngetRouter = function(IPAddress)\n	// Load the router object.\n	router = get_router(IPAddress)\n	if not router then\n		error(""Could not find a router at the given address: "" + IPAddress)\n		return null\n	end if\n\n	return router\nend function\n\npadSpaces = function(s, l, p="" "")\n	if typeof(s) == ""number"" then s = s + """"\n	if s.len >= l then return s\n	padString = """"\n	c = l - s.len\n	while c > 0\n		padString = padString + p\n		c = c - 1\n	end while\n	return (s+padString)\nend function\n\npadSpacesRight = function(s, l, p="" "")\n	if typeof(s) == ""number"" then s = s + """"\n	if s.len >= l then return s\n	padString = """"\n	c = l - s.len\n	while c > 0\n		padString = p + padString\n		c = c - 1\n	end while\n	return (padString+s)\nend function\n\nextractMetaLibs = function(router)\n	returnValue = []\n\n	if typeof(router) == ""router"" then\n		externalPorts = router.used_ports\n	else if typeof(router) == ""string"" then\n		externalPorts = get_router().device_ports(router)\n	end if\n\n	metaxploit = loadMetaXPloit()\n\n	if typeof(router) == ""router"" then\n		routerLib = metaxploit.net_use(router.public_ip).dump_lib\n	else\n		routerLib = metaxploit.net_use(get_router().public_ip).dump_lib\n	end if\n\n	if routerLib then\n		if typeof(router) == ""router"" then\n			returnValue.push({""public_ip"": router.public_ip, ""local_ip"": router.local_ip, ""port_number"":-1, ""metaLib"":routerLib})\n		else\n			returnValue.push({""public_ip"": get_router().public_ip, ""local_ip"": router, ""port_number"":-1, ""metaLib"":routerLib})\n		end if\n	else\n		error(""Could not map exploit library to router at: "" + router.public_ip)\n	end if\n\n	for port in externalPorts\n		metalib = null\n		if typeof(router) == ""router"" then\n			metalib = metaxploit.net_use(router.public_ip, port.port_number)\n		else\n			metalib = metaxploit.net_use(router, port.port_number)\n		end if\n		if not metalib then continue\n		metalib = metalib.dump_lib\n		if not metalib then\n			error(""Could not map exploit to public port at: "" + router.public_ip + "":"" + port.port_number)\n		else\n			if typeof(router) == ""router"" then\n				returnValue.push({""public_ip"": router.public_ip,""local_ip"": port.get_lan_ip, ""port_number"":port.port_number, ""metaLib"":metalib})\n			else\n				returnValue.push({""public_ip"": get_router().public_ip,""local_ip"": port.get_lan_ip, ""port_number"":port.port_number, ""metaLib"":metalib})\n			end if\n		end if\n	end for\n\n	return returnValue\nend function\n\nloadExploits = function(metaLib)\n	// Loads all the exploits appropriate for\n	if typeof(metaLib) == ""string"" then\n		fileName = metaLib\n	else\n		fileName = getLibFileName(metaLib)\n	end if\n\n	filePath = ""/lib/exploits/""\n\n	get_shell.host_computer.touch(filePath, fileName)\n	exploitLibFile = get_shell.host_computer.File(filePath+fileName)\n\n	if not exploitLibFile then\n		error(""Could not find exploit library."")\n		return false\n	end if\n\n	info(""Loading library.."")\n\n	rValue = []\n	newKey = false\n	lines = exploitLibFile.get_content.split(""\n"")\n	info(""Library contains "" + lines.len + "" lines of data."")\n\n	for line in lines\n		if line.len == 0 then continue\n		colsUntrimmed = line.split(""::"")\n		cols = []\n		for col in colsUntrimmed\n			cols.push(col.trim)\n		end for\n		if cols.len < 2 then continue\n		if cols[0] == ""exploit"" then\n			if newKey then rValue.push(newKey)\n			newKey = {""type"": cols[1]}\n		else if cols[0] == ""parameters"" or cols[0] == ""requirements"" then\n			newKey[cols[0]] = cols[1:]\n		else\n			newKey[cols[0]] = cols[1]\n		end if\n	end for\n	if newKey then rValue.push(newKey)\n\n	return rValue\nend function\n\ndisplayLocalMap = function(localMachineIP)\n	// Display the ports open on this machine\n	router = get_router()\n	localPorts = router.device_ports(localMachineIP)\n	externalPorts = router.used_ports\n\n	print(""\n<b>Local Machine at "" + localMachineIP)\n	if localPorts.len == 0 then print(""| | --> <i>No local ports detected.</b>"")\n	for localPort in localPorts\n		s = ""| |""\n		if localPort.is_closed then\n			s = s + ""-X-> ""\n		else\n			s = s + ""---> ""\n		end if\n		s = padSpacesRight(s + "":"" + localPort.port_number + "" "", 6)\n		s = s + router.port_info(localPort)\n		for externalPort in externalPorts\n			iPort = router.ping_port(externalPort.port_number)\n			if iPort.port_number == localPort.port_number and iPort.get_lan_ip == localMachineIP then\n				s = s + ""--> External Address: "" + router.public_ip + "":"" + externalPort.port_number\n			end if\n		end for\n		print(s)\n	end for\n\n	print(""|\n|---> <b>""+router.essid_name+""</b> (""+router.bssid_name+"")"")\n	print(""      Public IP: <b>"" + router.public_ip + ""</b>  Private IP: <b>"" + router.local_ip + ""</b>"")\n	routerLib = loadMetaXPloit().net_use(router.public_ip).dump_lib\n	whoisLines = whois(router.public_ip).split(""\n"")\n	for whoisLine in whoisLines\n		if whoisLine.len > 1 then\n			cols = whoisLine.split("":"")\n			print(""      <b>"" + padSpacesRight(cols[0], 25) + "":</b> "" + cols[1:].join(""""))\n		end if\n	end for\n	print(""      "" + routerLib.lib_name + "" is at version: "" + routerLib.version)\nend function\n\ndisplayRouterMap = function(mRouter)\n	// This routine simply displays the router.\n	if mRouter.essid_name == """" then\n		essid_name = ""<i>No ESSID</i>""\n	else\n		essid_name = mRouter.essid_name\n	end if\n\n	print(""\n<b>""+essid_name+""</b> (""+mRouter.bssid_name+"")"")\n	print(""Public IP: <b>"" + mRouter.public_ip + ""</b>  Private IP: <b>"" + mRouter.local_ip + ""</b>"")\n	routerLib = loadMetaXPloit().net_use(mRouter.public_ip).dump_lib\n	whoisLines = whois(mRouter.public_ip).split(""\n"")\n	for whoisLine in whoisLines\n		if whoisLine.len > 1 then\n			cols = whoisLine.split("":"")\n			print(""<b>"" + padSpacesRight(cols[0], 25) + "":</b> "" + cols[1:].join(""""))\n		end if\n	end for\n	print(routerLib.lib_name + "" is at version: "" + routerLib.version)\n\n	portFwds = []\n	blankPorts = []\n	for externalPort in mRouter.used_ports\n		internal = mRouter.ping_port(externalPort.port_number)\n		if internal then portFwds.push({""external"":externalPort, ""internal"":internal})\n		arrows = ""--->""\n		arrows2 = "" ---> ""\n		if externalPort.is_closed then arrows = ""-X->""\n		if not mRouter.ping_port(externalPort.port_number) then\n			arrows2 = "" ---> ? ""\n		else if mRouter.ping_port(externalPort.port_number).is_closed then\n			arrows2 = "" -X-> ""\n		end if\n		print("" |  |""+arrows+"" :"" + padSpaces(externalPort.port_number, 5) +"" "" + padSpaces(mRouter.port_info(externalPort).split("" "")[0], 8) + "" "" + padSpaces(mRouter.port_info(externalPort).split("" "")[1], 8) + arrows2 + externalPort.get_lan_ip)\n	end for\n\n	if not mRouter.devices_lan_ip then\n		print("" |-> <i>No local machines detected.</i>"")\n	else\n		for localMachine in mRouter.devices_lan_ip\n			print("" |-> <b>Machine at "" + localMachine + ""</b>"")\n			vbar = ""|""\n			if mRouter.devices_lan_ip.indexOf(localMachine) == (mRouter.devices_lan_ip.len-1) then vbar = "" ""\n			if not mRouter.device_ports(localMachine) then\n				print("" ""+vbar+""   |--> <i>No ports detected.</i>"")\n			else\n				for port in mRouter.device_ports(localMachine)\n					arrows = ""-->""\n					if port.is_closed then arrows = ""-X>""\n					toPrint = "" ""+vbar+""   |""+arrows+"" :"" + padSpaces(port.port_number, 5) + "" "" + padSpaces(mRouter.port_info(port).split("" "")[0], 8) + "" "" + padSpaces(mRouter.port_info(port).split("" "")[1], 8)\n					for portFwd in portFwds\n						if port.get_lan_ip == portFwd.internal.get_lan_ip and port.port_number == portFwd.internal.port_number then toPrint = toPrint + "" ---> external port "" + portFwd.external.port_number\n					end for\n					print(toPrint)\n				end for\n			end if\n		end for\n	end if\nend function\n\ngetLibFileName = function(metaLib)\n	return metaLib.lib_name + ""_v"" + metaLib.version + "".txt""\nend function\n\nwriteExploits = function(exploits, metaLib)\n	fileName = getLibFileName(metaLib)\n	filePath = ""/lib/exploits/""\n\n	get_shell.host_computer.touch(filePath, fileName)\n	file = get_shell.host_computer.File(filePath+fileName)\n\n	outputString = """"\n	if not file then\n		error(""Could not open "" + filename + "" for output."")\n		return false\n	end if\n	for exploit in exploits\n		if exploit.hasIndex(""type"") then outputString = outputString + ""exploit::"" + exploit.type + ""\n""\n		for key in exploit.indexes\n			if key == ""memory"" then outputString = outputString + ""     ""\n			if key == ""string"" or key == ""requirements"" then outputString = outputString + ""     ""\n			if key == ""parameters"" then outputString = outputString + ""     ""\n			outputString = outputString + key\n			value = exploit[key]\n			if typeof(value) == ""string"" then\n				outputString = outputString + ""::"" + value\n			else if typeof(value) == ""list"" then\n				for val in value\n					outputString = outputString + ""::"" + val\n				end for\n			else\n				error(""writeExploits: Don't know what to do with type: "" + typeof(value) + "" while writing key: "" + key)\n				return false\n			end if\n			outputString = outputString + ""\n""\n		end for\n	end for\n	file.set_content(outputString)\nend function\n\nscanTarget = function(target)\n	// Scans the target and appends the data to the file as needed.\n\n	metaxploit = loadMetaXPloit()\n	addresses = metaxploit.scan(target)\n	info(""Found "" + addresses.len + "" memory addresses."")\n\n	info(""Updating library..."")\n\n	expList = []\n	expMap = false\n	requirements = false\n	for address in addresses\n		exploits = metaxploit.scan_address(target, address)\n		lines = exploits.split(""\n"")\n		for line in lines\n			info(""Analyzing: "" + line)\n			if line.len == 0 then continue\n			if line.indexOf(""Unsafe check"") == 0 then\n				if expMap then\n					if requirements then\n						expMap.push(""requirements"")\n						expMap[""requirements""] = requirements\n						info(""Adding requirements to object"")\n					end if\n					expList.push(expMap)\n					info(""pushing object: "" + expMap)\n				end if\n				startPos = line.indexOf(""<b>"")+3\n				endPos = line.indexOf(""</b>"")\n				info(""Creating new object with keystring: "" + line[startPos:endPos])\n				expMap = {""exploit"":""Unknown"", ""string"":line[startPos:endPos], ""memory"":address}\n				requirements = false\n			else if line[0] == ""*"" then\n				if requirements then\n					requirements = requirements + ""::"" + line\n					info(""Updated requirements: "" + requirements)\n				else\n					info(""New requirements set: "" + line)\n					requirements = line\n				end if\n			end if\n		end for\n	end for\n	if expMap then\n		if requirements then\n			expMap.push(""requirements"")\n			expMap[""requirements""] = requirements\n			info(""Adding requirements to object"")\n		end if\n		expList.push(expMap)\n		info(""pushing object: "" + expMap)\n	end if\n\n\n	fileName = getLibFileName(target)\n	filePath = ""/lib/exploits/""\n\n	get_shell.host_computer.touch(filePath, fileName)\n	exploitLibFile = get_shell.host_computer.File(filePath+fileName)\n\n	newEntries = """"\n	for exp in expList\n		if target.lib_name == ""kernel_router.so"" then exp.exploit = ""Router""\n		newEntries = newEntries + ""exploit::"" + exp.exploit+""\n""\n		newEntries = newEntries + ""     memory::"" + exp.memory+""\n""\n		newEntries = newEntries + ""     string::"" + exp.string+""\n""\n		if exp.hasIndex(""requirements"") then newEntries = newEntries + ""     requirements::""+exp.requirements+""\n""\n		if target.lib_name == ""kernel_router.so"" then\n			newEntries = newEntries + ""     parameters::Local IP Address\n""\n		end if\n	end for\n\n	exploitLibFile.set_content(exploitLibFile.get_content + newEntries)\n	info(""library updated."")\n\n	writeExploits(removeDuplicates(loadExploits(target)), target)\nend function\n\nremoveDuplicates = function(exploits)\n	index1 = -1\n	startCount = exploits.len\n	for exploit in exploits\n		index1 = index1 + 1\n		index2 = exploits.len -1\n		while index2 > index1\n			if exploit.memory == exploits[index2].memory and exploit.string == exploits[index2].string then exploits.remove(index2)\n			end if\n			index2 = index2 - 1\n		end while\n	end for\n	finalCount = exploits.len\n	info(""Removed "" + (startCount-finalCount) + "" duplicate items from exploit library."")\n	return exploits\nend function\n\nget_choice = function(choices, default = -1)\n	c = 0\n	for choice in choices\n		if c == 0 then\n			print(""<b>"" + choices[0] + ""</b>"")\n		else\n			selString = ""<b>["" + c + ""]</b>""\n			print(padSpaces(selString, 12) + choices[c])\n		end if\n		c = c + 1\n	end for\n	if default > -1 then\n		prompt = ""[default=""+default+""] > ""\n	else\n		prompt = ""> ""\n	end if\n	while 1\n		user_choice = user_input(prompt)\n		if user_choice.len == 0 and default > -1 then return default\n		user_choice = user_choice.to_int\n		if not typeof(user_choice) == ""number"" or user_choice < 1 or user_choice >= c then\n			error(""Not a valid choice"")\n			continue\n		end if\n		return user_choice\n	end while\nend function\n\nget_yesno = function(default, prompt = """")\n	if prompt.len > 0 then print(""<b>""+prompt+""</b>"")\n	if default then\n		prompt = ""[Enter = Yes] > ""\n	else\n		prompt = ""[Enter = No] > ""\n	end if\n	while 1\n		resp = user_input(prompt)\n		if resp.len == 0 then return default\n		if resp.lower[0] == ""y"" then return true\n		if resp.lower[0] == ""n"" then return false\n	end while\nend function\n\nchooseMetaLib = function(metaLibs)\n	while 1\n		print(""\n<b>Found the following entry point(s): </b>"")\n		c = 0\n		for metaLib in metaLibs\n			c = c + 1\n			if metaLib.port_number == -1 then\n				print(""<b>["" + c + ""] "" + metaLib.metaLib.lib_name + ""</b> (Version: "" + metaLib.metaLib.version + "") --> "" + metaLib.local_ip)\n			else\n				print(""<b>["" + c + ""] "" + metaLib.metaLib.lib_name + ""</b> (Version: "" + metaLib.metaLib.version + "") --> "" + metaLib.local_ip + "":"" + metaLib.port_number)\n			end if\n			print(""     <i>"" + loadExploits(metaLib.metaLib).len + "" exploits on file.</i>"")\n		end for\n		print(""<b>[S]</b> Scan an entry point for exploits."")\n		print(""<b>[A]</b> Scan ALL entry points for new exploits."")\n		print(""<b>[X]</b> None.  Exit now."")\n\n		print(""Which one would you like to use?"")\n		i = user_input(""> "")\n		if i.len == 0 then continue\n		if i.lower[0] == ""x"" then return null\n		if i.lower[0] == ""a"" then\n			print(""Scanning <b>ALL</b> libraries for vulnerabilities"")\n			for metaLib in metaLibs\n				print(""Scanning "" + metaLib.metaLib.lib_name + "", version "" + metaLib.metaLib.version)\n				scanTarget(metaLib.metaLib)\n			end for\n			continue\n		end if\n		if i.lower[0] == ""s"" then\n			choices = [""Choose which library to scan""]\n			for metaLib in metaLibs\n				choices.push(metaLib.metaLib.lib_name + "", version "" + metaLib.metaLib.version)\n			end for\n			userChoice = get_choice(choices)\n			scanTarget(metaLibs[userChoice-1].metaLib)\n			continue\n		end if\n		i = i.to_int\n		if i < 1 or i > c then\n			error(""Not a valid response.  Try again"")\n			continue\n		end if\n		return metaLibs[i-1]\n	end while\nend function\n\nchangeExploitType = function(exploitToChange, target, newType)\n	info(""Updating exploit type from "" + exploitToChange.type + "" to "" + newType)\n	newExploit = exploitToChange\n	exploitList = loadExploits(target)\n	c = -1\n	for exploit in exploitList\n		c = c + 1\n		if exploit.memory == exploitToChange.memory and exploit.string == exploitToChange.string then\n			if newType.lower == ""shell"" or newType.lower == ""computer"" or newType.lower == ""file"" then\n				exploitList[c].type = newType\n				info(""Changing entry "" + c + "" to "" + newType)\n				newExploit = exploitList[c]\n			else if newType.lower == ""rootpass"" or newType.lower == ""userpass"" then\n				if newType.lower == ""rootpass"" then\n					exploitList[c].type = ""Change root password""\n				else\n					exploitList[c].type = ""Change user password""\n				end if\n				if not exploitList[c].hasIndex(""parameters"") then exploitList[c].push(""parameters"")\n				exploitList[c].parameters = [""New Password""]\n				newExploit = exploitList[c]\n			end if\n		end if\n	end for\n\n	writeExploits(exploitList, target)\n	return newExploit\nend function\n\nrunExploit = function(exploit, target)\n	while 1\n		info(""\n<b>Applying exploit <i>"" + exploit.type + ""</i> against target: <i>"" + target.lib_name + ""</i></b>"")\n\n		ps = []\n		if exploit.hasIndex(""parameters"") then\n			print(""<b>Additional information needed.  Please answer the following questions</b>"")\n			for parameter in exploit.parameters\n				ps.push(user_input(parameter + "" >""))\n			end for\n		end if\n\n		if ps.len == 0 then\n			overflowResult = target.overflow(exploit.memory, exploit.string)\n		else if ps.len == 1 then\n			overflowResult = target.overflow(exploit.memory, exploit.string, ps[0])\n		else if ps.len == 2 then\n			overflowResult = target.overflow(exploit.memory, exploit.string, ps[0], ps[1])\n		else if ps.len == 3 then\n			overflowResult = target.overflow(exploit.memory, exploit.string, ps[0], ps[1], ps[2])\n		else\n			error(""Too many parameters"")\n			return null\n		end if\n\n		info(""Result is an object of type <i>"" + typeof(overflowResult) + ""</i>"")\n\n		if typeof(overflowResult) == ""null"" then\n			choices = [""\nA null object may indicate either a failure or a need to include more information.\nPlease indicate which of the following is the case:""]\n			choices.push(""The attack failed because one or more requirements were not met."")\n			choices.push(""The attack is listed as the wrong type or needs to be defined."")\n			choice = get_choice(choices, 1)\n			if choice == 1 then\n				return null\n			else if choice == 2 then\n				choices_b = [""\n<b>Which type of attack should this be listed as?""]\n				choices_b.push(""A root user password change"")\n				choices_b.push(""A regular user password change"")\n				choices_b.push(""Nevermind, leave it as it is."")\n				choice_b = get_choice(choices_b, choices_b.len-1)\n				if choice_b == 1 then\n					changeExploitType(exploit, target, ""rootpass"")\n					return\n				else if choice_b == 2 then\n					changeExploitType(exploit, target, ""userpass"")\n					return\n				else\n					continue\n				end if\n			end if\n		else if typeof(overflowResult) == ""shell"" or typeof(overflowResult) == ""computer"" or typeof(overflowResult) == ""file"" then\n			if not exploit.type.lower == typeof(overflowResult) then\n				changeExploitType(exploit, target, typeof(overflowResult).upper[0] + typeof(overflowResult)[1:])\n			end if\n			return overflowResult\n		else\n			return overflowResult\n		end if\n	end while\nend function\n\ngetAccessString = function(fileObj)\n	perm = """"\n\n	if fileObj.has_permission(""r"") then\n		perm = ""r""\n	else\n		perm = ""-""\n	end if\n\n	if fileObj.has_permission(""w"") then\n		perm = perm + ""w""\n	else\n		perm = perm + ""-""\n	end if\n\n	if fileObj.has_permission(""x"") then\n		perm = perm + ""x""\n	else\n		perm = perm + ""-""\n	end if\n\n	return perm\nend function\n\ngetColorString = function(fileObj)\n	if fileObj.has_permission(""r"") and fileObj.has_permission(""w"") then return(""88FFFF"")\n	if fileObj.has_permission(""r"") then return(""8888FF"")\n	if fileObj.has_permission(""w"") then return(""88FF88"")\n	return(""FF8888"")\nend function\n\nmessWithProcs = function(computer)\n	while 1\n		choices = [""\n\n<b>The following processes have been detected on the machine:</b>\nChoose the one you would like to kill.""]\n		procs = computer.show_procs.split(""\n"")\n		PIDs = []\n		for b in range(0, procs.len-1)\n			procCols = procs[b].split("" "")\n			for c in range(0, procCols.len-2)\n				procCols[c] = padSpaces(procCols[c], 10)\n			end for\n			if b == 0 then\n				choices[0] = choices[0] + ""\n     "" + procCols.join("""")\n			else\n				choices.push(procCols.join(""""))\n				PIDs.push(procCols[1])\n			end if\n		end for\n		choices.push(""<i>Leave these procs do their proc'ing (exit)</i>"")\n		choice = get_choice(choices, choices.len-1)\n		if choice == choices.len-1 then return\n		print(""<b>Attempting to kill process ID: "" + PIDs[choice-1])\n		r = computer.close_program(PIDs[choice-1].to_int)\n		if r == 1 then\n			print(""<b>SUCCESS!</b>  You really showed that process you can murder it."")\n		else if r == 0 then\n			error(""Could not find the process."")\n		else\n			error(r)\n		end if\n	end while\nend function\n\nmessWithUsers = function(computer)\n	choices = [""\n<b>What would you like to do?</b>""]\n	choices.push(""Add a user."")\n	choices.push(""Delete a user."")\n	choices.push(""Forget it."")\n	choice = get_choice(choices, choices.len-1)\n	result = null\n	if choice == 1 then\n		un = user_input(""New user name? > "")\n		pw = user_input(""Password? > "")\n		result = computer.create_user(un,pw)\n	else if choice == 2 then\n		un = user_input(""User to delete? >"")\n		delHome = get_yesno(false,""Delete home directory?"")\n		result = computer.delete_user(un, delHome)\n	else\n		return\n	end if\n	if result == 1 then\n		print(""<b>SUCCESS!</b>"")\n	else\n		error(result)\n	end if\nend function\n\ncrackPasswordFile = function(filePtr, hostInfo="""")\n	crypto = loadLibrary(""crypto.so"", true)\n	lines = filePtr.get_content.split(""\n"")\n	for line in lines\n		results = []\n		line = split(line.trim, "":"")\n		if line.len == 2 and line[1].len == 32 then\n			print(""Cracking MD5 hash for user: <b><i>"" + line[0] + ""</b></i> in file: <b><i>"" + filePtr.path + ""</b></i>"")\n			pw = crypto.decipher(line[1])\n			if pw then\n				print(""Password: [""+pw+""]"")\n				get_shell().host_computer.touch(home_dir, ""crackedPasswords.txt"")\n				f = get_shell().host_computer.File(home_dir+""/crackedPasswords.txt"")\n				f.set_content(f.get_content + ""\n"" + padSpaces(line[0]+""@""+pw, 30) + "" "" + hostInfo + "": "" + filePtr.name)\n			end if\n		end if\n	end for\nend function\n\ncrackAllFiles = function(filePtr, hostInfo="""")\n	subDirs = filePtr.get_folders\n	files = filePtr.get_files\n	for file in files\n		if file.has_permission(""r"") and not file.is_binary then crackPasswordFile(file, hostInfo)\n	end for\n	for dir in subDirs\n		crackAllFiles(dir, hostInfo)\n	end for\nend function\n\ncrackAllFilesFromTop = function(filePtr, hostInfo="""")\n	while filePtr.parent\n		filePtr = filePtr.parent\n	end while\n	crackAllFiles(dir, hostInfo)\nend function\n\nunlockAllFiles = function(filePtr)\n	subDirs = filePtr.get_folders\n	files = filePtr.get_files\n	for file in files\n		file.chmod(""o+rwx"")\n	end for\n	for directory in subDirs\n		directory.chmod(""o+rwx"")\n		unlockAllFiles(directory)\n	end for\nend function\n\nfindUnlockedRWString = function(readPerm, writePerm)\n	if readPerm and writePerm then\n		return ""read and write""\n	else if readPerm then\n		return ""read""\n	else if writePerm then\n		return ""write""\n	else\n		return ""no""\n	end if\nend function\n\nfindUnlocked = function(dirPtr)\n	directories = dirPtr.get_folders\n	files = dirPtr.get_files\n	if dirPtr.has_permission(""w"") then print(""Directory at <b>"" + dirPtr.path +""</b> has write permission."")\n	if files.len > 0 then\n		for file in files\n			if not findUnlockedRWString(file.has_permission(""r""), file.has_permission(""w""))==""no"" then\n				print(""File at <b>"" + file.path + ""</b> has "" + findUnlockedRWString(file.has_permission(""r""), file.has_permission(""w"")) + "" permissions."")\n			end if\n		end if\n	end if\n	if directories.len > 0 then\n		for directory in directories\n			findUnlocked(directory)\n		end for\n	end if\nend function\n\nbrowseFiles = function(dirPtr, hostInfo = """")\n	while not dirPtr.parent == null\n		dirPtr = dirPtr.parent\n	end while\n	rootPtr = dirPtr\n	while 1\n		directories = dirPtr.get_folders\n		files = dirPtr.get_files\n		choices = [""\n\n<b>Contents of "" + dirPtr.path + "":</b>\n     <color=#"" + getColorString(dirPtr) + "">"" + dirPtr.permissions + padSpaces("""", 19) + ""<.>"" ]\n		isRoot = (dirPtr.path == ""/"")\n\n		if not isRoot then choices.push(""<color=#""+getColorString(dirPtr.parent)+"">"" + dirPtr.parent.permissions + ""                   <..></color>"")\n\n		for directory in directories\n			choices.push(""<color=#""+getColorString(directory)+"">"" + directory.permissions + "" "" + padSpacesRight(directory.owner, 8, "" "") + "" "" + padSpaces(directory.group, 8, "" "") + "" ./"" + padSpaces(directory.name, 19, ""."") +""<dir></color>"")\n		end for\n\n		if files.len > 25 then\n			files = files[0:24]\n			print(""Possible file bomb detected.  Only showing the first 25 files."")\n		end if\n\n		for file in files\n			binString = ""<binary>""\n			if not file.is_binary then binString = ""<text>""\n			choices.push(""<color=#""+getColorString(file)+"">"" + file.permissions + "" "" + padSpacesRight(file.owner, 8, "" "") + "" "" + padSpaces(file.group, 8, "" "") + "" "" + padSpaces(file.name, 20, ""."") + ""."" + padSpaces(binString, 9) + file.size + "" bytes</color>"")\n		end for\n\n		choices.push(""--- Stop browsing files ---"")\n\n		choice = get_choice(choices, choices.len-1)\n\n		if choice == choices.len-1 then break\n\n		if (not isRoot and choice == 1) then\n			// The user has chosen to back up a directory\n			dirPtr = dirPtr.parent\n		else if (directories.len > 0 and isRoot and choice <= directories.len) or (directories.len > 0 and not isRoot and choice <= (1+directories.len)) then\n			// The user has chosen a directory\n			if isRoot then\n				dirPtr = directories[choice-1]\n			else\n				dirPtr = directories[choice-2]\n			end if\n		else if (file.len > 0 and isRoot and choice > directories.len) or (file.len > 0 and not isRoot and choice > (directories.len+1)) then\n			filePtr = null\n			if isRoot then\n				filePtr = files[choice - directories.len - 1]\n			else\n				filePtr = files[choice - directories.len - 2]\n			end if\n			choicesb = [""\n\n<b>What would you like to do with this file?""]\n			choicesb.push(""Display contents"")\n			choicesb.push(""Download file"")\n			choicesb.push(""Over-write file"")\n			choicesb.push(""Delete"")\n			choicesb.push(""Append"")\n			choicesb.push(""Scan for and crack passwords"")\n			//choicesb.push(""Unlock all files from here down"")\n			choicesb.push(""Do nothing"")\n			choiceb = get_choice(choicesb, choicesb.len-1)\n			if choiceb == choicesb.len-1 then break\n			if choiceb == 1 or choiceb == 2 then\n				if filePtr.get_content then\n					if choiceb == 1 then\n						print(""\n\n<b>Contents of file: "" + filePtr.name + ""</b>"")\n						print(filePtr.get_content)\n					else\n						get_shell.host_computer.touch(home_dir + ""/Downloads"", filePtr.name)\n						print(""Saving file to: "" + home_dir + ""/Downloads/"" + filePtr.name)\n						x = get_shell.host_computer.File(home_dir + ""/Downloads/"" + filePtr.name).set_content(filePtr.get_content)\n						if(x == 1) then\n							print(""File downloaded successfully."")\n						else\n							error(x)\n						end if\n					end if\n				else\n					error(""Could not read the contents of this file - Check permissions and file type."")\n				end if\n			else if choiceb == 3 then\n				x = user_input(""<b>Please enter what you would like to replace the contents of this file with.</b>\n"")\n				x = filePtr.set_content(x)\n				if(x == 1) then\n					print(""File overwritten successfully."")\n				else\n					error(x)\n				end if\n			else if choiceb == 4 then\n				if get_yesno(false, ""Are you sure you want to delete this file?"") then\n					x = filePtr.delete\n					if x == """" then\n						print("" .. File deleted successfully."")\n					else\n						error(x)\n					end if\n				end if\n			else if choiceb == 5 then\n				x = user_input(""<b>Please enter what you would like to add to the contents of this file.</b>\n"")\n				x = filePtr.set_content(filePtr.get_content + ""\n"" + x)\n				if(x == 1) then\n					print(""File appended successfully."")\n				else\n					error(x)\n				end if\n			else if choiceb == 6 then\n				if not filePtr.get_content then\n					error(""Could not read the contents of this file - Check permissions and file type."")\n					continue\n				else\n					print(""Scanning contents..."")\n					crackPasswordFile(filePtr)\n					print(""Cracked passwords have been saved in <b><i>"" + home_dir + ""/crackedPasswords.txt</b></i>"")\n				end if\n			end if\n		end if\n	end while\nend function\n\nipAddr = null\n\nfor param in params\n	if is_valid_ip(nslookup(param)) then\n		ipAddr = nslookup(param)\n	else if is_valid_ip(param) then\n		ipAddr = param\n	end if\n	if ipAddr then break\nend for\n\n\n\nprint(""<color=#FF1111>  *      `           `             ) </color>"")\nprint(""<color=#DD4433> (  `       `               `     ( /( </color>"")\nprint(""<color=#BB8855> )\))(     (       `  (   `       )\())</color>"")\nprint(""<color=#99CC77>((_)()\    )\    (    )(     (   ((_)\ </color>"")\nprint(""<color=#77EE99>(_()((_)  ((_)   )\   (()\    )\  __((_)</color>"")\nprint(""<color=#5588BB><b>|  \/  |</b>  (_)  ((_)   ((_)  ((_)  <b>\ \/ /</b></color>"")\nprint(""<color=#3344DD><b>| |\/| |  | | / _|  | '_| / _ \  >  < </b></color>"")\nprint(""<color=#1111FF><b>|_|  |_|  |_| \__|  |_|   \___/ /_/\_\</b></color>"")\nprint(""                                <i>Version <b>"" + microx_version + ""</b></i>"")\nprint()\n\nif not ipAddr then exit(""<B>Usage: microx (optional -v) <IP Address></B>"")\n\nwhile 1\n	if is_lan_ip(ipAddr) then\n		displayLocalMap(ipAddr)\n		metaLibs = extractMetaLibs(ipAddr)\n	else\n		router = getRouter(ipAddr)\n		displayRouterMap(router)\n		metaLibs = extractMetaLibs(router)\n	end if\n\n	while 1\n		metaLib = chooseMetaLib(metaLibs)\n		if not metaLib then exit(""Thanks for using microx"")\n\n		exploits = loadExploits(metaLib.metaLib)\n\n		if exploits.len == 0 then\n			error(""Sorry, there are no exploits for the entry point.  Try scanning for some."")\n			print("""")\n			continue\n		end if\n\n		break\n	end while\n\n	while 1\n		// Exploit loop\n		choices = [""\n\n<b>Choose which exploit you would like to use:</b>""]\n		exploits = loadExploits(metaLib.metaLib)\n		for exploit in exploits\n			stringToAdd = ""<b> "" + exploit.type + ""</b>""\n			if exploit.hasIndex(""requirements"") then\n				for requirement in exploit.requirements\n					stringToAdd = stringToAdd + ""\n       "" + requirement\n				end for\n			end if\n			choices.push(stringToAdd)\n		end for\n		choices.push(""<i>I'm scared. Get me out of here.</i>"")\n\n		userChoice = get_choice(choices, choices.len-1)\n		if userChoice > exploits.len then break\n		exploit = exploits[userChoice-1]\n\n		exploitObj = runExploit(exploit, metaLib.metaLib)\n\n		if typeof(exploitObj) == ""shell"" or typeof(exploitObj) == ""ftpshell"" then\n			result = get_yesno(false, typeof(exploitObj) + "": This can alert the admin.  Are you sure you want to open it now?"")\n			if result then\n				get_shell.launch(""/usr/bin/AdminMonitor.exe"")\n				exploitObj.start_terminal\n			end if\n		else if typeof(exploitObj) == ""computer"" then\n			while 1\n				choices = [""\n\n<b>You have unlocked a computer object.  You can:</b>""]\n				choices.push(""Browse through the files."")\n				choices.push(""Create a file on the computer."")\n				choices.push(""Mess with users"")\n				choices.push(""Mess with processes"")\n				choices.push(""Scan entire machine for passwords (and crack them)"")\n				choices.push(""Scan entire machine for vulnerable directories and files"")\n				choices.push(""Nothing."")\n				choice = get_choice(choices, choices.len-1)\n				if choice == choices.len-1 then break\n				if choice == 1 then\n					browseFiles(exploitObj.File(""/""), router.public_ip + ""->"" + exploitObj.local_ip)\n				else if choice == 2 then\n					path = user_input(""Path to new file (Do not include file name) >"")\n					filename = user_input(""File name for new file > "")\n					x = exploitObj.touch(path, filename)\n					if x==1 then\n						print(""File successfully created at "" + path + ""/"" + filename)\n					else\n						error(x)\n					end if\n				else if choice == 3 then\n					messWithUsers(exploitObj)\n				else if choice == 4 then\n					messWithProcs(exploitObj)\n				else if choice == 5 then\n					crackAllFiles(exploitObj.File(""/""), metaLib.public_ip + "" --> "" + metaLib.local_ip)\n					print(""Cracked passwords have been saved in <b><i>"" + home_dir + ""/crackedPasswords.txt</b></i>"")\n				else if choice == 6 then\n					findUnlocked(exploitObj.File(""/""))\n				end if\n			end while\n		else if typeof(exploitObj) == ""file"" then\n			choices = [""\n\n<b>You have unlocked file access.  You can:</b>""]\n			choices.push(""Browse Files"")\n			choices.push(""Scan entire machine for passwords (and crack them)"")\n			choices.push(""Scan entire machine for vulnerable directories and files"")\n			choices.push(""Nothing."")\n			choice = get_choice(choices, choices.len-1)\n			if choice == choices.len-1 then break\n			if choice == 1 then\n				browseFiles(exploitObj)\n			else if choice == 2 then\n				while exploitObj.parent\n					exploitObj = exploitObj.parent\n				end while\n				crackAllFiles(exploitObj, metaLib.public_ip + "" --> "" + metaLib.local_ip)\n				print(""Cracked passwords have been saved in <b><i>"" + home_dir + ""/crackedPasswords.txt</b></i>"")\n			else if choice == 3 then\n				while exploitObj.parent\n					exploitObj = exploitObj.parent\n				end while\n				findUnlocked(exploitObj)\n			end if\n		end if\n	end while\nend while"
encode = "encode_version = ""0.2""\n\n// .get_content no longer allowed in Encode/Decode\n// key = get_shell.host_computer.File(""/server/.ssh/id_key"").get_content //can be located\nanywhere, need to be a 32 character key\nkey = ""IAbBpjLQq8UZTY6xAHdPE4YLWeI3wZqL"" // change this unless you are a skid\n\npad32 = function(text)\n	pad = char(32)\n	i = 32 - text.len\n	return(text + pad*i)\nend function\n\nfill = function(text, block)\n	a = []\n	sStart = ((block-1)*32)\n	sEnd = block*32\n	text = text[sStart:sEnd]\n	if text.len < 32 then\n		text = pad32(text)\n	end if\n	for i in text.indexes\n		a.push(text[i].code)\n	end for\n	return a\nend function\n\nhex = function(int)\n  lookup = [""0"",""1"",""2"",""3"",""4"",""5"",""6"",""7"",""8"",""9"",""a"",""b"",""c"",""d"",""e"",""f""]\n  x = int/16\n  y = int%16\n  return(lookup[x]+lookup[y])\nend function\n\nEncode = function(text)\n	numBlocks = ceil(text.len/32)\n\n	blocks = []\n	for i in range(1, numBlocks)\n		blocks.push(fill(text, i))\n	end for\n\n	keyblock = []\n	keyblock = fill(key, 1)\n\n	result = []\n	for i in blocks.indexes\n		for j in keyblock.indexes\n			result.push(bitwise(""^"", blocks[i][j], keyblock[j]))\n		end for\n	end for\n\n  ciphertext = """"\n  for i in result.indexes\n    ciphertext = ciphertext + hex(result[i])\n  end for\n\n	return ciphertext\n\nend function"
decode = "decode_version = ""0.2""\n\n// .get_content no longer allowed in Encode/Decode\n// key = get_shell.host_computer.File(""/server/.ssh/id_key"").get_content //can be located anywhere, need to be a 32 character key\nkey = ""IAbBpjLQq8UZTY6xAHdPE4YLWeI3wZqL"" // change this unless you are a skid\n\nfill = function(text, block)\n	a = []\n	sStart = ((block-1)*32)\n	sEnd = block*32\n	text = text[sStart:sEnd]\n	if text.len < 32 then\n		text = pad32(text)\n	end if\n	for i in text.indexes\n		a.push(text[i].code)\n	end for\n	return a\nend function\n\nhSplit = function(text, block)\n	a = []\n	sStart = ((block-1)*64)\n	sEnd = block*64\n	text = text[sStart:sEnd]\n	for i in text.indexes\n		if i%2 == 0 then a.push(text[i]+text[i+1])\n	end for\n	for i in a.indexes\n		a[i] = hex_to_int(a[i])\n	end for\n	return a\nend function\n\nhex_to_int = function(hex)\n	lookup = {""0"":0,""1"":1,""2"":2,""3"":3,""4"":4,""5"":5,""6"":6,""7"":7,""8"":8,""9"":9,""a"":10,""b"":11,""c"":12,""d"":13,""e"":14,""f"":15}\n	x = hex[0]\n	y = hex[1]\n	result = (lookup[x]*16)+lookup[y]\n	return(result)\nend function\n\nDecode = function(cipher)\n	if cipher.len%64 != 0 then exit(""Error: cipher length incorrect"")\n	numBlocks = cipher.len/64\n\n	blocks = []\n	for i in range(1, numBlocks)\n		blocks.push(hSplit(cipher, i))\n	end for\n\n	keyblock = []\n	keyblock = fill(key, 1)\n\n	result = []\n	for i in blocks.indexes\n		for j in keyblock.indexes\n			result.push(bitwise(""^"", blocks[i][j], keyblock[j]))\n		end for\n	end for\n\n	plaintext = """"\n	for i in result.indexes\n		plaintext = plaintext + char(result[i])\n	end for\n	return plaintext.trim\n\nend function"
scrape = "// scraper\npadSpaces = function(s, l, p="" "")\n	if typeof(s) == ""number"" then s = s + """"\n	if s.len >= l then return s\n	padString = """"\n	c = l - s.len\n	while c > 0\n		padString = padString + p\n		c = c - 1\n	end while\n	return (s+padString)\nend function\n\npadSpacesRight = function(s, l, p="" "")\n	if typeof(s) == ""number"" then s = s + """"\n	if s.len >= l then return s\n	padString = """"\n	c = l - s.len\n	while c > 0\n		padString = p + padString\n		c = c - 1\n	end while\n	return (padString+s)\nend function\n\nPasswordFile = function(filePtr)\n	lines = filePtr.get_content.split(""\n"")\n	for line in lines\n		results = []\n		line = split(line.trim, "":"")\n		if line.len == 2 and line[1].len == 32 then\n			print(""Found MD5 hash for user: <b><i>"" + line[0] + ""</b></i> in file: <b><i>"" + filePtr.path + ""</b></i>"")\n			get_shell().host_computer.touch(home_dir, ""uncrackedPasswords.txt"")\n			f = get_shell().host_computer.File(home_dir+""/uncrackedPasswords.txt"")\n			f.set_content(f.get_content + ""\n"" + padSpaces(line[0]+"":""+line[1], 30) + "" "" + get_shell().host_computer.public_ip + "": "" + filePtr.name)\n		end if\n	end for\nend function\n\nAllFiles = function(filePtr)\n	subDirs = filePtr.get_folders\n	files = filePtr.get_files\n	for file in files\n		if file.has_permission(""r"") and not file.is_binary then PasswordFile(file)\n	end for\n	for dir in subDirs\n		AllFiles(dir)\n	end for\nend function\n\nAllFiles(get_shell().host_computer.File(""/""))"
ritz = "// ritz\nloadLibrary = function(libFileName, search)\n	paths=[""""]\n	if search then paths = [current_path, ""/lib"", ""/bin"", ""/usr/bin""]\n	for p in paths\n		lib = include_lib(p + ""/"" + libFileName)\n		if lib then return lib\n	end for\n	error(""Could not find requested library: "" + libFileName)\n	return false\nend function\n\npadSpaces = function(s, l, p="" "")\n	if typeof(s) == ""number"" then s = s + """"\n	if s.len >= l then return s\n	padString = """"\n	c = l - s.len\n	while c > 0\n		padString = padString + p\n		c = c - 1\n	end while\n	return (s+padString)\nend function\n\npadSpacesRight = function(s, l, p="" "")\n	if typeof(s) == ""number"" then s = s + """"\n	if s.len >= l then return s\n	padString = """"\n	c = l - s.len\n	while c > 0\n		padString = p + padString\n		c = c - 1\n	end while\n	return (padString+s)\nend function\n\ncrackPasswordFile = function(filePtr)\n	crypto = loadLibrary(""crypto.so"", true)\n	lines = filePtr.get_content.split(""\n"")\n	for line in lines\n		results = []\n		line = split(line.trim, "":"")\n		line2 = split(line[1], "" "")\n		if line2[0].len == 32 then\n			print(""Cracking MD5 hash for user: <b><i>"" + line[0] + ""</b></i> in file: <b><i>"" + filePtr.path + ""</b></i>"")\n			pw = crypto.decipher(line[1])\n			get_shell().host_computer.touch(home_dir, ""crackedPasswords.txt"")\n			f = get_shell().host_computer.File(home_dir+""/crackedPasswords.txt"")\n			f.set_content(f.get_content + ""\n"" + padSpaces(line[0]+""@""+pw, 30) + "" "" + line2[1] + "": "" + line[2])\n		end if\n	end for\nend function\n\ncrackPasswordFile(host_computer.File(params[0]))"
chall = "//chmod all Files\na = get_shell().host_computer.File(""/"")\na.chmod(""o-rwx"", 1)\na.chmod(""u-rwx"", 1)\na.chmod(""g-rwx"", 1)\n\nexit(""File Permissions Removed"")"
libcheck = "//LibraryVersionChecker\nlibCheck = ""0.0.1""\n\nprint(""========================"")\nprint(""Library Version Checker:"")\nprint(""========================"")\nprint(""Developed by: Camel_Reloaded - v"" + libCheck)\n\nprint("" "")\nprint(""Active library versions:"")\nmetaxploit = include_lib(""/lib/metaxploit.so"")\nif not metaxploit then\n    print(""/lib/metaxploit.so/ could not be accessed or is missing."")\n    exit(""<color=red>Can't operate without metaxploit, terminating...</color>"")\nelse\n    metax = metaxploit.load(""/lib/metaxploit.so"")\n    print(""/lib/metaxploit.so/: "" + metax.version)\nend if\nprint("" "")\ncrypto = metaxploit.load(""/lib/crypto.so"")\nif not crypto then\n    print(""/lib/crypto.so/ could not be accessed or is missing."")\nelse\n    print(""/lib/crypto.so/: "" + crypto.version)\nend if\nprint("" "")\nkernel = metaxploit.load(""/lib/kernel_module.so"")\nif not kernel then\n    print(""/lib/kernel_module.so/ could not be accessed or is missing."")\nelse\n    print(""/lib/kernel_module.so/: "" + kernel.version)\nend if\nprint("" "")\ninit = metaxploit.load(""/lib/init.so"")\nif not init then\n    print(""/lib/init.so/ could not be accessed or is missing."")\nelse\n    print(""/lib/init.so/: "" + init.version)\nend if\nprint("" "")\nnet = metaxploit.load(""/lib/net.so"")\nif not net then\n    print(""/lib/net.so/ could not be accessed or is missing."")\nelse\n    print(""/lib/net.so/: "" + net.version)\nend if\n\nprint("" "")\nexit(""Terminating..."")"

shell = get_shell()
host = shell.host_computer

host.create_folder(home_dir, "Scripts")
host.create_folder(home_dir, "Binaries")
host.create_folder(home_dir, "Installers")
host.create_folder(home_dir, "Libararies")

scripts = home_dir+"/Scripts"
home_bins = home_dir+"/Binaries"

host.touch(scripts, "microx.src")
host.touch(scripts, "encode.src")
host.touch(scripts, "decode.src")
host.touch(scripts, "scrape.src")
host.touch(scripts, "ritz.src")
host.touch(scripts, "chall.src")
host.touch(scripts, "libcheck.src")

host.File(scripts+"/microx.src").set_content(microx)
host.File(scripts+"/encode.src").set_content(encode)
host.File(scripts+"/decode.src").set_content(decode)
host.File(scripts+"/scrape.src").set_content(scrape)
host.File(scripts+"/ritz.src").set_content(ritz)
host.File(scripts+"/chall.src").set_content(chall)
host.File(scripts+"/libcheck.src").set_content(libcheck)

shell.build(scripts+"/microx.src", home_bins)
file = host.File(home_bins+"/microx")
file.copy("/bin", "microx")

shell.build(scripts+"/scrape.src", home_bins)
file = host.File(home_bins+"/scrape")
file.copy("/bin", "srcape")

shell.build(scripts+"/ritz.src", home_bins)
file = host.File(home_bins+"/ritz")
file.copy("/bin", "ritz")

shell.build(scripts+"/libcheck.src", home_bins)
file = host.File(home_bins+"/libcheck")
file.copy("/bin", "libcheck")

shell.build(scripts+"/decode.src", home_bins)
file = host.File(home_bins+"/decode")
file.rename("decode.bin")

shell.build(scripts+"/chall.src", home_bins)

shell.launch("/bin/sudo", "chmod -R o-rwx /")
